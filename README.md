# AssertJ - Assertions Generator

[![CI](https://github.com/assertj/assertj-assertions-generator/actions/workflows/main.yml/badge.svg?branch=main)](https://github.com/assertj/assertj-assertions-generator/actions/workflows/main.yml?query=branch%3Amain)

## Overview 

The Assertions Generator can create specific assertions for your classes. It comes with :
* a CLI tool (this project) 
* a [**maven plugin**](https://github.com/assertj/assertj-assertions-generator-maven-plugin).
* a [**gradle plugin**](https://github.com/assertj/assertj-generator-gradle-plugin).

Let's say you have a `Player` class with `name` and `team` properties. The generator will create a `PlayerAssert` assertions class with `hasName` and `hasTeam` assertions. This allows you to write :

```java
assertThat(mvp).hasName("Lebron James").hasTeam("Miami Heat");
```

## Documentation

Please have a look at the complete documentation in the [**assertions generator section**](http://joel-costigliola.github.io/assertj/assertj-assertions-generator.html), including a [**quickstart guide**](http://joel-costigliola.github.io/assertj/assertj-assertions-generator.html#quickstart).

### Output folder strategies

#### Default strategy - as is
* If file all ready exists it will be overwritten
* If `generateAssertionsInPackage` is not set, the assertion classes will be written to the same package as the class they are asserting.
* If `generateAssertionsInPackage` is set all assertion classes will be written flat to that package
* If `hierarchical` is set to true, an abstract assertion class containing tha asserts will be written together with a domain class specific entry class that contains the assertThat-entry method for that class
* If `hierarchical` is set to false, both the generated asserts and the entry method will be written to the same concrete class for the domain class.


#### ContinuousExecutionStrategy - to be implemented
This puts the generated asserts into the Abstract class, and does not overwrite the Entry class so the developer can place custom asserts there.
* Concrete Assertion-implementations for classes will not be overwritten
* Abstract Assertion classes containing the generated assertion-methods will be overwritten
* Implies
  * `hierarchical` true
    * The abstract class will be overwritten with new content on every execution of this plugin. This is for the generated assertions to evolve together with the class being asserted.
    * A concrete entry class for the class being asserted will be generated. This will not be overwritten, and is where you can put assertion methods you create yourself.
* If `generateAssertionsForAllFields` is false, the abstract classes will be generated in a subfolder with the name `generated`

Solution:
- put abstract classes in package `generated` Abstract klasse 
- put concrete classes in full package path or generateAssertionsInPackage, as is
- Skip concrete class if excists
- Fix import statements when `generateAssertionsInPackage` is set, by ensuring correct imports for classes generated by this plugin.

New config params
* `numberOfPackageLevelsToKeepFromRight` in combination with `generateAssertionsInPackage` will preserve the specified number of packages counted from right to left on the specified packages to import.

* Possible future extensions
* If `generateAssertionsInPackage` is set all assertion classes will be written flat to that package.
* If `generateAssertionsForAllFields` is true, the abstract classes will be generated in the same package structure as the class being asserted to gain access to package and default scoped variables. TODO: What about private fileds?
