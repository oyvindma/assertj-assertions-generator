package org.assertj.assertions.generator.data.typereference;

import java.util.Objects;
import org.assertj.core.api.AbstractObjectAssert;
import org.assertj.core.api.Assertions;
import org.assertj.core.internal.Iterables;

/**
 * {@link InheritingOwningClassFromSamePackage} specific assertions - Generated by CustomAssertionGenerator.
 */
@javax.annotation.processing.Generated(value="assertj-assertions-generator")
public class InheritingOwningClassFromSamePackageAssert extends AbstractObjectAssert<InheritingOwningClassFromSamePackageAssert, InheritingOwningClassFromSamePackage> {

  /**
   * Creates a new <code>{@link InheritingOwningClassFromSamePackageAssert}</code> to make assertions on actual InheritingOwningClassFromSamePackage.
   * @param actual the InheritingOwningClassFromSamePackage we want to make assertions on.
   */
  public InheritingOwningClassFromSamePackageAssert(InheritingOwningClassFromSamePackage actual) {
    super(actual, InheritingOwningClassFromSamePackageAssert.class);
  }

  /**
   * An entry point for InheritingOwningClassFromSamePackageAssert to follow AssertJ standard <code>assertThat()</code> statements.<br>
   * With a static import, one can write directly: <code>assertThat(myInheritingOwningClassFromSamePackage)</code> and get specific assertion with code completion.
   * @param actual the InheritingOwningClassFromSamePackage we want to make assertions on.
   * @return a new <code>{@link InheritingOwningClassFromSamePackageAssert}</code>
   */
  @org.assertj.core.util.CheckReturnValue
  public static InheritingOwningClassFromSamePackageAssert assertThat(InheritingOwningClassFromSamePackage actual) {
    return new InheritingOwningClassFromSamePackageAssert(actual);
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param classInDifferentPackageAsArray_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsArray_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter()).contains(classInDifferentPackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   *
   * @param classInDifferentPackageAsArray_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsArray_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter()).containsOnly(classInDifferentPackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsArray_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsArray_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter()).doesNotContain(classInDifferentPackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsArray_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsArray_getter but had :\n  <%s>";

    // check that it is not empty
    if (actual.getClassInDifferentPackageAsArray_getter().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getClassInDifferentPackageAsArray_getter()));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning()).contains(classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   *
   * @param classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning()).containsOnly(classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning()).doesNotContain(classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check that it is not empty
    if (actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning()));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter is equal to the given one.
   * @param classInDifferentPackageAsField_getter the given classInDifferentPackageAsField_getter to compare the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter is not equal to the given one.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsField_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage classInDifferentPackageAsField_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInDifferentPackageAsField_getter of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage actualClassInDifferentPackageAsField_getter = actual.getClassInDifferentPackageAsField_getter();
    if (!Objects.deepEquals(actualClassInDifferentPackageAsField_getter, classInDifferentPackageAsField_getter)) {
      failWithMessage(assertjErrorMessage, actual, classInDifferentPackageAsField_getter, actualClassInDifferentPackageAsField_getter);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter_subclassSamePackageAsOwning is equal to the given one.
   * @param classInDifferentPackageAsField_getter_subclassSamePackageAsOwning the given classInDifferentPackageAsField_getter_subclassSamePackageAsOwning to compare the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter_subclassSamePackageAsOwning to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter_subclassSamePackageAsOwning is not equal to the given one.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage classInDifferentPackageAsField_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInDifferentPackageAsField_getter_subclassSamePackageAsOwning of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage actualClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning = actual.getClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning();
    if (!Objects.deepEquals(actualClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning, classInDifferentPackageAsField_getter_subclassSamePackageAsOwning)) {
      failWithMessage(assertjErrorMessage, actual, classInDifferentPackageAsField_getter_subclassSamePackageAsOwning, actualClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param classInDifferentPackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsGenericList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsGenericList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsGenericList_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsGenericList_getter but had :\n  <%s>";

    // check
    if (actual.getClassInDifferentPackageAsGenericList_getter().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInDifferentPackageAsGenericList_getter());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param classInDifferentPackageAsList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter == null) failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter == null) failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_getter(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter == null) failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsList_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsList_getter but had :\n  <%s>";

    // check
    if (actual.getClassInDifferentPackageAsList_getter().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInDifferentPackageAsList_getter());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsList_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter contains the given KlassInSamePackage elements.
   * @param classInSamePackageAsArray_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsArray_getter(KlassInSamePackage... classInSamePackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter == null) failWithMessage("Expecting classInSamePackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter()).contains(classInSamePackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   *
   * @param classInSamePackageAsArray_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter does not contain all given KlassInSamePackage elements and nothing else.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsArray_getter(KlassInSamePackage... classInSamePackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter == null) failWithMessage("Expecting classInSamePackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter()).containsOnly(classInSamePackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter does not contain the given KlassInSamePackage elements.
   *
   * @param classInSamePackageAsArray_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsArray_getter(KlassInSamePackage... classInSamePackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter == null) failWithMessage("Expecting classInSamePackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter()).doesNotContain(classInSamePackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsArray_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsArray_getter but had :\n  <%s>";

    // check that it is not empty
    if (actual.getClassInSamePackageAsArray_getter().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getClassInSamePackageAsArray_getter()));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning contains the given KlassInSamePackage elements.
   * @param classInSamePackageAsArray_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsArray_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning()).contains(classInSamePackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   *
   * @param classInSamePackageAsArray_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements and nothing else.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsArray_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning()).containsOnly(classInSamePackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements.
   *
   * @param classInSamePackageAsArray_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsArray_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning()).doesNotContain(classInSamePackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsArray_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsArray_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check that it is not empty
    if (actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning()));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter is equal to the given one.
   * @param classInSamePackageAsField_getter the given classInSamePackageAsField_getter to compare the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter is not equal to the given one.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsField_getter(KlassInSamePackage classInSamePackageAsField_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInSamePackageAsField_getter of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    KlassInSamePackage actualClassInSamePackageAsField_getter = actual.getClassInSamePackageAsField_getter();
    if (!Objects.deepEquals(actualClassInSamePackageAsField_getter, classInSamePackageAsField_getter)) {
      failWithMessage(assertjErrorMessage, actual, classInSamePackageAsField_getter, actualClassInSamePackageAsField_getter);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter_subclassSamePackageAsOwning is equal to the given one.
   * @param classInSamePackageAsField_getter_subclassSamePackageAsOwning the given classInSamePackageAsField_getter_subclassSamePackageAsOwning to compare the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter_subclassSamePackageAsOwning to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter_subclassSamePackageAsOwning is not equal to the given one.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsField_getter_subclassSamePackageAsOwning(KlassInSamePackage classInSamePackageAsField_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInSamePackageAsField_getter_subclassSamePackageAsOwning of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    KlassInSamePackage actualClassInSamePackageAsField_getter_subclassSamePackageAsOwning = actual.getClassInSamePackageAsField_getter_subclassSamePackageAsOwning();
    if (!Objects.deepEquals(actualClassInSamePackageAsField_getter_subclassSamePackageAsOwning, classInSamePackageAsField_getter_subclassSamePackageAsOwning)) {
      failWithMessage(assertjErrorMessage, actual, classInSamePackageAsField_getter_subclassSamePackageAsOwning, actualClassInSamePackageAsField_getter_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains the given KlassInSamePackage elements.
   * @param classInSamePackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_getter(KlassInSamePackage... classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains the given KlassInSamePackage elements in Collection.
   * @param classInSamePackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_getter(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_getter(KlassInSamePackage... classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains <b>only</b> the given KlassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_getter(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain the given KlassInSamePackage elements.
   *
   * @param classInSamePackageAsGenericList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_getter(KlassInSamePackage... classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain the given KlassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsGenericList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_getter(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsGenericList_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsGenericList_getter but had :\n  <%s>";

    // check
    if (actual.getClassInSamePackageAsGenericList_getter().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInSamePackageAsGenericList_getter());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains the given KlassInSamePackage elements.
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains the given KlassInSamePackage elements in Collection.
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements.
   *
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains the given KlassInSamePackage elements.
   * @param classInSamePackageAsIterable_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_getter(KlassInSamePackage... classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter == null) failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains the given KlassInSamePackage elements in Collection.
   * @param classInSamePackageAsIterable_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_getter(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsIterable_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_getter(KlassInSamePackage... classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter == null) failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains <b>only</b> the given KlassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsIterable_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_getter(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain the given KlassInSamePackage elements.
   *
   * @param classInSamePackageAsIterable_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_getter(KlassInSamePackage... classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter == null) failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain the given KlassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsIterable_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_getter(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsIterable_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsIterable_getter but had :\n  <%s>";

    // check
    if (actual.getClassInSamePackageAsIterable_getter().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInSamePackageAsIterable_getter());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains the given KlassInSamePackage elements.
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains the given KlassInSamePackage elements in Collection.
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements.
   *
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsIterable_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param classInDifferentPackageAsGenericList_owningClass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_owningClass(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_owningClass == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_owningClass parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsGenericList_owningClass, classInDifferentPackageAsGenericList_owningClass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsGenericList_owningClass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_owningClass(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_owningClass == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_owningClass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsGenericList_owningClass, classInDifferentPackageAsGenericList_owningClass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_owningClass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_owningClass(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_owningClass == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_owningClass parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsGenericList_owningClass, classInDifferentPackageAsGenericList_owningClass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_owningClass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_owningClass(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_owningClass == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_owningClass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsGenericList_owningClass, classInDifferentPackageAsGenericList_owningClass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsGenericList_owningClass the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_owningClass(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_owningClass == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_owningClass parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsGenericList_owningClass, classInDifferentPackageAsGenericList_owningClass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsGenericList_owningClass the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_owningClass(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_owningClass == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_owningClass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsGenericList_owningClass, classInDifferentPackageAsGenericList_owningClass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_owningClass is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsGenericList_owningClass() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsGenericList_owningClass but had :\n  <%s>";

    // check
    if (actual.classInDifferentPackageAsGenericList_owningClass.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInDifferentPackageAsGenericList_owningClass);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsGenericList_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass contains the given KlassInSamePackage elements.
   * @param classInSamePackageAsGenericList_owningClass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_owningClass(KlassInSamePackage... classInSamePackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_owningClass == null) failWithMessage("Expecting classInSamePackageAsGenericList_owningClass parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsGenericList_owningClass, classInSamePackageAsGenericList_owningClass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass contains the given KlassInSamePackage elements in Collection.
   * @param classInSamePackageAsGenericList_owningClass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_owningClass(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_owningClass == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_owningClass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsGenericList_owningClass, classInSamePackageAsGenericList_owningClass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_owningClass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_owningClass(KlassInSamePackage... classInSamePackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_owningClass == null) failWithMessage("Expecting classInSamePackageAsGenericList_owningClass parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsGenericList_owningClass, classInSamePackageAsGenericList_owningClass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass contains <b>only</b> the given KlassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_owningClass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_owningClass(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_owningClass == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_owningClass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsGenericList_owningClass, classInSamePackageAsGenericList_owningClass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass does not contain the given KlassInSamePackage elements.
   *
   * @param classInSamePackageAsGenericList_owningClass the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_owningClass(KlassInSamePackage... classInSamePackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_owningClass == null) failWithMessage("Expecting classInSamePackageAsGenericList_owningClass parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsGenericList_owningClass, classInSamePackageAsGenericList_owningClass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass does not contain the given KlassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsGenericList_owningClass the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_owningClass(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_owningClass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_owningClass == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_owningClass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsGenericList_owningClass, classInSamePackageAsGenericList_owningClass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsGenericList_owningClass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_owningClass is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsGenericList_owningClass() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsGenericList_owningClass but had :\n  <%s>";

    // check
    if (actual.classInSamePackageAsGenericList_owningClass.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInSamePackageAsGenericList_owningClass);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains the given KlassInSamePackage elements.
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains the given KlassInSamePackage elements in Collection.
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements.
   *
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_subclassSamePackageAsOwning(KlassInSamePackage... classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsGenericList_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsGenericList_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param klassInDifferentPackageAsArray_owningKlasses the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInDifferentPackageAsArray_owningKlasses(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsArray_owningKlasses) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsArray_owningKlasses == null) failWithMessage("Expecting klassInDifferentPackageAsArray_owningKlasses parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInDifferentPackageAsArray_owningKlasses).contains(klassInDifferentPackageAsArray_owningKlasses);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   *
   * @param klassInDifferentPackageAsArray_owningKlasses the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInDifferentPackageAsArray_owningKlasses(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsArray_owningKlasses) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsArray_owningKlasses == null) failWithMessage("Expecting klassInDifferentPackageAsArray_owningKlasses parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInDifferentPackageAsArray_owningKlasses).containsOnly(klassInDifferentPackageAsArray_owningKlasses);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param klassInDifferentPackageAsArray_owningKlasses the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInDifferentPackageAsArray_owningKlasses(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsArray_owningKlasses) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsArray_owningKlasses == null) failWithMessage("Expecting klassInDifferentPackageAsArray_owningKlasses parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInDifferentPackageAsArray_owningKlasses).doesNotContain(klassInDifferentPackageAsArray_owningKlasses);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no klassInDifferentPackageAsArray_owningKlasses.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_owningKlasses is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoKlassInDifferentPackageAsArray_owningKlasses() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have klassInDifferentPackageAsArray_owningKlasses but had :\n  <%s>";

    // check that it is not empty
    if (actual.klassInDifferentPackageAsArray_owningKlasses.length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.klassInDifferentPackageAsArray_owningKlasses));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param klassInDifferentPackageAsArray_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInDifferentPackageAsArray_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInDifferentPackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInDifferentPackageAsArray_subclassSamePackageAsOwning).contains(klassInDifferentPackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   *
   * @param klassInDifferentPackageAsArray_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInDifferentPackageAsArray_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInDifferentPackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInDifferentPackageAsArray_subclassSamePackageAsOwning).containsOnly(klassInDifferentPackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param klassInDifferentPackageAsArray_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInDifferentPackageAsArray_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInDifferentPackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInDifferentPackageAsArray_subclassSamePackageAsOwning).doesNotContain(klassInDifferentPackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no klassInDifferentPackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsArray_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoKlassInDifferentPackageAsArray_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have klassInDifferentPackageAsArray_subclassSamePackageAsOwning but had :\n  <%s>";

    // check that it is not empty
    if (actual.klassInDifferentPackageAsArray_subclassSamePackageAsOwning.length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.klassInDifferentPackageAsArray_subclassSamePackageAsOwning));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsField_owningKlass is equal to the given one.
   * @param klassInDifferentPackageAsField_owningKlass the given klassInDifferentPackageAsField_owningKlass to compare the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsField_owningKlass to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsField_owningKlass is not equal to the given one.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInDifferentPackageAsField_owningKlass(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage klassInDifferentPackageAsField_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting klassInDifferentPackageAsField_owningKlass of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage actualKlassInDifferentPackageAsField_owningKlass = actual.klassInDifferentPackageAsField_owningKlass;
    if (!Objects.deepEquals(actualKlassInDifferentPackageAsField_owningKlass, klassInDifferentPackageAsField_owningKlass)) {
      failWithMessage(assertjErrorMessage, actual, klassInDifferentPackageAsField_owningKlass, actualKlassInDifferentPackageAsField_owningKlass);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsField_subclassSamePackageAsOwning is equal to the given one.
   * @param klassInDifferentPackageAsField_subclassSamePackageAsOwning the given klassInDifferentPackageAsField_subclassSamePackageAsOwning to compare the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsField_subclassSamePackageAsOwning to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsField_subclassSamePackageAsOwning is not equal to the given one.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInDifferentPackageAsField_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage klassInDifferentPackageAsField_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting klassInDifferentPackageAsField_subclassSamePackageAsOwning of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage actualKlassInDifferentPackageAsField_subclassSamePackageAsOwning = actual.klassInDifferentPackageAsField_subclassSamePackageAsOwning;
    if (!Objects.deepEquals(actualKlassInDifferentPackageAsField_subclassSamePackageAsOwning, klassInDifferentPackageAsField_subclassSamePackageAsOwning)) {
      failWithMessage(assertjErrorMessage, actual, klassInDifferentPackageAsField_subclassSamePackageAsOwning, actualKlassInDifferentPackageAsField_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param klassInDifferentPackageAsList_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInDifferentPackageAsList_owningKlass(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsList_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsList_owningKlass == null) failWithMessage("Expecting klassInDifferentPackageAsList_owningKlass parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.klassInDifferentPackageAsList_owningKlass, klassInDifferentPackageAsList_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   * @param klassInDifferentPackageAsList_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInDifferentPackageAsList_owningKlass(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> klassInDifferentPackageAsList_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (klassInDifferentPackageAsList_owningKlass == null) {
      failWithMessage("Expecting klassInDifferentPackageAsList_owningKlass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.klassInDifferentPackageAsList_owningKlass, klassInDifferentPackageAsList_owningKlass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   * @param klassInDifferentPackageAsList_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInDifferentPackageAsList_owningKlass(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsList_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsList_owningKlass == null) failWithMessage("Expecting klassInDifferentPackageAsList_owningKlass parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.klassInDifferentPackageAsList_owningKlass, klassInDifferentPackageAsList_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param klassInDifferentPackageAsList_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInDifferentPackageAsList_owningKlass(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> klassInDifferentPackageAsList_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (klassInDifferentPackageAsList_owningKlass == null) {
      failWithMessage("Expecting klassInDifferentPackageAsList_owningKlass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.klassInDifferentPackageAsList_owningKlass, klassInDifferentPackageAsList_owningKlass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param klassInDifferentPackageAsList_owningKlass the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInDifferentPackageAsList_owningKlass(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsList_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsList_owningKlass == null) failWithMessage("Expecting klassInDifferentPackageAsList_owningKlass parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.klassInDifferentPackageAsList_owningKlass, klassInDifferentPackageAsList_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   *
   * @param klassInDifferentPackageAsList_owningKlass the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInDifferentPackageAsList_owningKlass(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> klassInDifferentPackageAsList_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (klassInDifferentPackageAsList_owningKlass == null) {
      failWithMessage("Expecting klassInDifferentPackageAsList_owningKlass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.klassInDifferentPackageAsList_owningKlass, klassInDifferentPackageAsList_owningKlass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no klassInDifferentPackageAsList_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_owningKlass is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoKlassInDifferentPackageAsList_owningKlass() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have klassInDifferentPackageAsList_owningKlass but had :\n  <%s>";

    // check
    if (actual.klassInDifferentPackageAsList_owningKlass.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.klassInDifferentPackageAsList_owningKlass);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   * @param klassInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInDifferentPackageAsList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsList_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.klassInDifferentPackageAsList_subclassSamePackageAsOwning, klassInDifferentPackageAsList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   * @param klassInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInDifferentPackageAsList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> klassInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (klassInDifferentPackageAsList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting klassInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.klassInDifferentPackageAsList_subclassSamePackageAsOwning, klassInDifferentPackageAsList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements and nothing else in whatever order.
   * @param klassInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInDifferentPackageAsList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsList_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.klassInDifferentPackageAsList_subclassSamePackageAsOwning, klassInDifferentPackageAsList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param klassInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInDifferentPackageAsList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> klassInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (klassInDifferentPackageAsList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting klassInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.klassInDifferentPackageAsList_subclassSamePackageAsOwning, klassInDifferentPackageAsList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   *
   * @param klassInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInDifferentPackageAsList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage... klassInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage varargs is not null.
    if (klassInDifferentPackageAsList_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.klassInDifferentPackageAsList_subclassSamePackageAsOwning, klassInDifferentPackageAsList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements in Collection.
   *
   * @param klassInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInDifferentPackageAsList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage> klassInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.typereference.different_package.KlassInDifferentPackage collection is not null.
    if (klassInDifferentPackageAsList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting klassInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.klassInDifferentPackageAsList_subclassSamePackageAsOwning, klassInDifferentPackageAsList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no klassInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInDifferentPackageAsList_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoKlassInDifferentPackageAsList_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have klassInDifferentPackageAsList_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.klassInDifferentPackageAsList_subclassSamePackageAsOwning.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.klassInDifferentPackageAsList_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass contains the given KlassInSamePackage elements.
   * @param klassInSamePackageAsArray_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInSamePackageAsArray_owningKlass(KlassInSamePackage... klassInSamePackageAsArray_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsArray_owningKlass == null) failWithMessage("Expecting klassInSamePackageAsArray_owningKlass parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInSamePackageAsArray_owningKlass).contains(klassInSamePackageAsArray_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   *
   * @param klassInSamePackageAsArray_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass does not contain all given KlassInSamePackage elements and nothing else.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInSamePackageAsArray_owningKlass(KlassInSamePackage... klassInSamePackageAsArray_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsArray_owningKlass == null) failWithMessage("Expecting klassInSamePackageAsArray_owningKlass parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInSamePackageAsArray_owningKlass).containsOnly(klassInSamePackageAsArray_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass does not contain the given KlassInSamePackage elements.
   *
   * @param klassInSamePackageAsArray_owningKlass the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInSamePackageAsArray_owningKlass(KlassInSamePackage... klassInSamePackageAsArray_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsArray_owningKlass == null) failWithMessage("Expecting klassInSamePackageAsArray_owningKlass parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInSamePackageAsArray_owningKlass).doesNotContain(klassInSamePackageAsArray_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no klassInSamePackageAsArray_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_owningKlass is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoKlassInSamePackageAsArray_owningKlass() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have klassInSamePackageAsArray_owningKlass but had :\n  <%s>";

    // check that it is not empty
    if (actual.klassInSamePackageAsArray_owningKlass.length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.klassInSamePackageAsArray_owningKlass));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning contains the given KlassInSamePackage elements.
   * @param klassInSamePackageAsArray_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInSamePackageAsArray_subclassSamePackageAsOwning(KlassInSamePackage... klassInSamePackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInSamePackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInSamePackageAsArray_subclassSamePackageAsOwning).contains(klassInSamePackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   *
   * @param klassInSamePackageAsArray_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements and nothing else.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInSamePackageAsArray_subclassSamePackageAsOwning(KlassInSamePackage... klassInSamePackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInSamePackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInSamePackageAsArray_subclassSamePackageAsOwning).containsOnly(klassInSamePackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements.
   *
   * @param klassInSamePackageAsArray_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInSamePackageAsArray_subclassSamePackageAsOwning(KlassInSamePackage... klassInSamePackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInSamePackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.klassInSamePackageAsArray_subclassSamePackageAsOwning).doesNotContain(klassInSamePackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no klassInSamePackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsArray_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoKlassInSamePackageAsArray_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have klassInSamePackageAsArray_subclassSamePackageAsOwning but had :\n  <%s>";

    // check that it is not empty
    if (actual.klassInSamePackageAsArray_subclassSamePackageAsOwning.length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.klassInSamePackageAsArray_subclassSamePackageAsOwning));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsField_owningKlass is equal to the given one.
   * @param klassInSamePackageAsField_owningKlass the given klassInSamePackageAsField_owningKlass to compare the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsField_owningKlass to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsField_owningKlass is not equal to the given one.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInSamePackageAsField_owningKlass(KlassInSamePackage klassInSamePackageAsField_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting klassInSamePackageAsField_owningKlass of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    KlassInSamePackage actualKlassInSamePackageAsField_owningKlass = actual.klassInSamePackageAsField_owningKlass;
    if (!Objects.deepEquals(actualKlassInSamePackageAsField_owningKlass, klassInSamePackageAsField_owningKlass)) {
      failWithMessage(assertjErrorMessage, actual, klassInSamePackageAsField_owningKlass, actualKlassInSamePackageAsField_owningKlass);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsField_subclassSamePackageAsOwning is equal to the given one.
   * @param klassInSamePackageAsField_subclassSamePackageAsOwning the given klassInSamePackageAsField_subclassSamePackageAsOwning to compare the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsField_subclassSamePackageAsOwning to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsField_subclassSamePackageAsOwning is not equal to the given one.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInSamePackageAsField_subclassSamePackageAsOwning(KlassInSamePackage klassInSamePackageAsField_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting klassInSamePackageAsField_subclassSamePackageAsOwning of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    KlassInSamePackage actualKlassInSamePackageAsField_subclassSamePackageAsOwning = actual.klassInSamePackageAsField_subclassSamePackageAsOwning;
    if (!Objects.deepEquals(actualKlassInSamePackageAsField_subclassSamePackageAsOwning, klassInSamePackageAsField_subclassSamePackageAsOwning)) {
      failWithMessage(assertjErrorMessage, actual, klassInSamePackageAsField_subclassSamePackageAsOwning, actualKlassInSamePackageAsField_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass contains the given KlassInSamePackage elements.
   * @param klassInSamePackageAsIterable_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInSamePackageAsIterable_owningKlass(KlassInSamePackage... klassInSamePackageAsIterable_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsIterable_owningKlass == null) failWithMessage("Expecting klassInSamePackageAsIterable_owningKlass parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.klassInSamePackageAsIterable_owningKlass, klassInSamePackageAsIterable_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass contains the given KlassInSamePackage elements in Collection.
   * @param klassInSamePackageAsIterable_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInSamePackageAsIterable_owningKlass(java.util.Collection<? extends KlassInSamePackage> klassInSamePackageAsIterable_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (klassInSamePackageAsIterable_owningKlass == null) {
      failWithMessage("Expecting klassInSamePackageAsIterable_owningKlass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.klassInSamePackageAsIterable_owningKlass, klassInSamePackageAsIterable_owningKlass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   * @param klassInSamePackageAsIterable_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInSamePackageAsIterable_owningKlass(KlassInSamePackage... klassInSamePackageAsIterable_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsIterable_owningKlass == null) failWithMessage("Expecting klassInSamePackageAsIterable_owningKlass parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.klassInSamePackageAsIterable_owningKlass, klassInSamePackageAsIterable_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass contains <b>only</b> the given KlassInSamePackage elements in Collection and nothing else in whatever order.
   * @param klassInSamePackageAsIterable_owningKlass the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInSamePackageAsIterable_owningKlass(java.util.Collection<? extends KlassInSamePackage> klassInSamePackageAsIterable_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (klassInSamePackageAsIterable_owningKlass == null) {
      failWithMessage("Expecting klassInSamePackageAsIterable_owningKlass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.klassInSamePackageAsIterable_owningKlass, klassInSamePackageAsIterable_owningKlass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass does not contain the given KlassInSamePackage elements.
   *
   * @param klassInSamePackageAsIterable_owningKlass the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInSamePackageAsIterable_owningKlass(KlassInSamePackage... klassInSamePackageAsIterable_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsIterable_owningKlass == null) failWithMessage("Expecting klassInSamePackageAsIterable_owningKlass parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.klassInSamePackageAsIterable_owningKlass, klassInSamePackageAsIterable_owningKlass);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass does not contain the given KlassInSamePackage elements in Collection.
   *
   * @param klassInSamePackageAsIterable_owningKlass the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInSamePackageAsIterable_owningKlass(java.util.Collection<? extends KlassInSamePackage> klassInSamePackageAsIterable_owningKlass) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (klassInSamePackageAsIterable_owningKlass == null) {
      failWithMessage("Expecting klassInSamePackageAsIterable_owningKlass parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.klassInSamePackageAsIterable_owningKlass, klassInSamePackageAsIterable_owningKlass.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no klassInSamePackageAsIterable_owningKlass.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_owningKlass is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoKlassInSamePackageAsIterable_owningKlass() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have klassInSamePackageAsIterable_owningKlass but had :\n  <%s>";

    // check
    if (actual.klassInSamePackageAsIterable_owningKlass.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.klassInSamePackageAsIterable_owningKlass);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning contains the given KlassInSamePackage elements.
   * @param klassInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInSamePackageAsIterable_subclassSamePackageAsOwning(KlassInSamePackage... klassInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsIterable_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.klassInSamePackageAsIterable_subclassSamePackageAsOwning, klassInSamePackageAsIterable_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning contains the given KlassInSamePackage elements in Collection.
   * @param klassInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasKlassInSamePackageAsIterable_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> klassInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (klassInSamePackageAsIterable_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting klassInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.klassInSamePackageAsIterable_subclassSamePackageAsOwning, klassInSamePackageAsIterable_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements and nothing else in whatever order.
   * @param klassInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInSamePackageAsIterable_subclassSamePackageAsOwning(KlassInSamePackage... klassInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsIterable_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.klassInSamePackageAsIterable_subclassSamePackageAsOwning, klassInSamePackageAsIterable_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning contains <b>only</b> the given KlassInSamePackage elements in Collection and nothing else in whatever order.
   * @param klassInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning does not contain all given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert hasOnlyKlassInSamePackageAsIterable_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> klassInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (klassInSamePackageAsIterable_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting klassInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.klassInSamePackageAsIterable_subclassSamePackageAsOwning, klassInSamePackageAsIterable_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements.
   *
   * @param klassInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInSamePackageAsIterable_subclassSamePackageAsOwning(KlassInSamePackage... klassInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage varargs is not null.
    if (klassInSamePackageAsIterable_subclassSamePackageAsOwning == null) failWithMessage("Expecting klassInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.klassInSamePackageAsIterable_subclassSamePackageAsOwning, klassInSamePackageAsIterable_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning does not contain the given KlassInSamePackage elements in Collection.
   *
   * @param klassInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning contains any given KlassInSamePackage elements.
   */
  public InheritingOwningClassFromSamePackageAssert doesNotHaveKlassInSamePackageAsIterable_subclassSamePackageAsOwning(java.util.Collection<? extends KlassInSamePackage> klassInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given KlassInSamePackage collection is not null.
    if (klassInSamePackageAsIterable_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting klassInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.klassInSamePackageAsIterable_subclassSamePackageAsOwning, klassInSamePackageAsIterable_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no klassInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's klassInSamePackageAsIterable_subclassSamePackageAsOwning is not empty.
   */
  public InheritingOwningClassFromSamePackageAssert hasNoKlassInSamePackageAsIterable_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have klassInSamePackageAsIterable_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.klassInSamePackageAsIterable_subclassSamePackageAsOwning.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.klassInSamePackageAsIterable_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }


}
