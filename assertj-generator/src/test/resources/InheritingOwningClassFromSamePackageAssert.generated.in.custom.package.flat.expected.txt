package my.assertions;

import java.util.Objects;
import org.assertj.assertions.generator.data.classRefTestdata.InheritingOwningClassFromSamePackage;
import org.assertj.core.api.AbstractObjectAssert;
import org.assertj.core.api.Assertions;
import org.assertj.core.internal.Iterables;

/**
 * {@link InheritingOwningClassFromSamePackage} specific assertions - Generated by CustomAssertionGenerator.
 */
@javax.annotation.processing.Generated(value="assertj-assertions-generator")
public class RefTestdataInheritingOwningClassFromSamePackageAssert extends AbstractObjectAssert<RefTestdataInheritingOwningClassFromSamePackageAssert, InheritingOwningClassFromSamePackage> {

  /**
   * Creates a new <code>{@link RefTestdataInheritingOwningClassFromSamePackageAssert}</code> to make assertions on actual InheritingOwningClassFromSamePackage.
   * @param actual the InheritingOwningClassFromSamePackage we want to make assertions on.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert(InheritingOwningClassFromSamePackage actual) {
    super(actual, RefTestdataInheritingOwningClassFromSamePackageAssert.class);
  }

  /**
   * An entry point for RefTestdataInheritingOwningClassFromSamePackageAssert to follow AssertJ standard <code>assertThat()</code> statements.<br>
   * With a static import, one can write directly: <code>assertThat(myInheritingOwningClassFromSamePackage)</code> and get specific assertion with code completion.
   * @param actual the InheritingOwningClassFromSamePackage we want to make assertions on.
   * @return a new <code>{@link RefTestdataInheritingOwningClassFromSamePackageAssert}</code>
   */
  @org.assertj.core.util.CheckReturnValue
  public static RefTestdataInheritingOwningClassFromSamePackageAssert assertThat(InheritingOwningClassFromSamePackage actual) {
    return new RefTestdataInheritingOwningClassFromSamePackageAssert(actual);
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsArray_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsArray_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter()).contains(classInDifferentPackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   *
   * @param classInDifferentPackageAsArray_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsArray_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter()).containsOnly(classInDifferentPackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsArray_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsArray_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter()).doesNotContain(classInDifferentPackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsArray_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsArray_getter but had :\n  <%s>";

    // check that it is not empty
    if (actual.getClassInDifferentPackageAsArray_getter().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getClassInDifferentPackageAsArray_getter()));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning()).contains(classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   *
   * @param classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning()).containsOnly(classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning()).doesNotContain(classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsArray_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check that it is not empty
    if (actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getClassInDifferentPackageAsArray_getter_subclassSamePackageAsOwning()));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter is equal to the given one.
   * @param classInDifferentPackageAsField_getter the given classInDifferentPackageAsField_getter to compare the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter is not equal to the given one.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsField_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage classInDifferentPackageAsField_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInDifferentPackageAsField_getter of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage actualClassInDifferentPackageAsField_getter = actual.getClassInDifferentPackageAsField_getter();
    if (!Objects.deepEquals(actualClassInDifferentPackageAsField_getter, classInDifferentPackageAsField_getter)) {
      failWithMessage(assertjErrorMessage, actual, classInDifferentPackageAsField_getter, actualClassInDifferentPackageAsField_getter);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter_subclassSamePackageAsOwning is equal to the given one.
   * @param classInDifferentPackageAsField_getter_subclassSamePackageAsOwning the given classInDifferentPackageAsField_getter_subclassSamePackageAsOwning to compare the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter_subclassSamePackageAsOwning to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_getter_subclassSamePackageAsOwning is not equal to the given one.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage classInDifferentPackageAsField_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInDifferentPackageAsField_getter_subclassSamePackageAsOwning of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage actualClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning = actual.getClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning();
    if (!Objects.deepEquals(actualClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning, classInDifferentPackageAsField_getter_subclassSamePackageAsOwning)) {
      failWithMessage(assertjErrorMessage, actual, classInDifferentPackageAsField_getter_subclassSamePackageAsOwning, actualClassInDifferentPackageAsField_getter_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsGenericList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsGenericList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsGenericList_getter(), classInDifferentPackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsGenericList_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsGenericList_getter but had :\n  <%s>";

    // check
    if (actual.getClassInDifferentPackageAsGenericList_getter().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInDifferentPackageAsGenericList_getter());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInDifferentPackageAsGenericList_getter_subclassSamePackageAsOwning());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter == null) failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter == null) failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_getter(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter == null) failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_getter(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsList_getter(), classInDifferentPackageAsList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsList_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsList_getter but had :\n  <%s>";

    // check
    if (actual.getClassInDifferentPackageAsList_getter().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInDifferentPackageAsList_getter());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning(), classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_getter_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsList_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInDifferentPackageAsList_getter_subclassSamePackageAsOwning());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsArray_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsArray_getter(ClassInSamePackage... classInSamePackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter == null) failWithMessage("Expecting classInSamePackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter()).contains(classInSamePackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   *
   * @param classInSamePackageAsArray_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter does not contain all given ClassInSamePackage elements and nothing else.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsArray_getter(ClassInSamePackage... classInSamePackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter == null) failWithMessage("Expecting classInSamePackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter()).containsOnly(classInSamePackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsArray_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsArray_getter(ClassInSamePackage... classInSamePackageAsArray_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter == null) failWithMessage("Expecting classInSamePackageAsArray_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter()).doesNotContain(classInSamePackageAsArray_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsArray_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsArray_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsArray_getter but had :\n  <%s>";

    // check that it is not empty
    if (actual.getClassInSamePackageAsArray_getter().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getClassInSamePackageAsArray_getter()));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsArray_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsArray_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning()).contains(classInSamePackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   *
   * @param classInSamePackageAsArray_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements and nothing else.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsArray_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning()).containsOnly(classInSamePackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsArray_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsArray_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsArray_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning()).doesNotContain(classInSamePackageAsArray_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsArray_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_getter_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsArray_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsArray_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check that it is not empty
    if (actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getClassInSamePackageAsArray_getter_subclassSamePackageAsOwning()));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter is equal to the given one.
   * @param classInSamePackageAsField_getter the given classInSamePackageAsField_getter to compare the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter is not equal to the given one.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsField_getter(org.assertj.assertions.generator.data.classRefTestdata.ClassInSamePackage classInSamePackageAsField_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInSamePackageAsField_getter of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.classRefTestdata.ClassInSamePackage actualClassInSamePackageAsField_getter = actual.getClassInSamePackageAsField_getter();
    if (!Objects.deepEquals(actualClassInSamePackageAsField_getter, classInSamePackageAsField_getter)) {
      failWithMessage(assertjErrorMessage, actual, classInSamePackageAsField_getter, actualClassInSamePackageAsField_getter);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter_subclassSamePackageAsOwning is equal to the given one.
   * @param classInSamePackageAsField_getter_subclassSamePackageAsOwning the given classInSamePackageAsField_getter_subclassSamePackageAsOwning to compare the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter_subclassSamePackageAsOwning to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_getter_subclassSamePackageAsOwning is not equal to the given one.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsField_getter_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.ClassInSamePackage classInSamePackageAsField_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInSamePackageAsField_getter_subclassSamePackageAsOwning of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.classRefTestdata.ClassInSamePackage actualClassInSamePackageAsField_getter_subclassSamePackageAsOwning = actual.getClassInSamePackageAsField_getter_subclassSamePackageAsOwning();
    if (!Objects.deepEquals(actualClassInSamePackageAsField_getter_subclassSamePackageAsOwning, classInSamePackageAsField_getter_subclassSamePackageAsOwning)) {
      failWithMessage(assertjErrorMessage, actual, classInSamePackageAsField_getter_subclassSamePackageAsOwning, actualClassInSamePackageAsField_getter_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_getter(ClassInSamePackage... classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains the given ClassInSamePackage elements in Collection.
   * @param classInSamePackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_getter(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_getter(ClassInSamePackage... classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains <b>only</b> the given ClassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_getter(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsGenericList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_getter(ClassInSamePackage... classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter does not contain the given ClassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsGenericList_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_getter(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsGenericList_getter(), classInSamePackageAsGenericList_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsGenericList_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsGenericList_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsGenericList_getter but had :\n  <%s>";

    // check
    if (actual.getClassInSamePackageAsGenericList_getter().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInSamePackageAsGenericList_getter());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains the given ClassInSamePackage elements in Collection.
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning(), classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsGenericList_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInSamePackageAsGenericList_getter_subclassSamePackageAsOwning());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsIterable_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_getter(ClassInSamePackage... classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter == null) failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains the given ClassInSamePackage elements in Collection.
   * @param classInSamePackageAsIterable_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_getter(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsIterable_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_getter(ClassInSamePackage... classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter == null) failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains <b>only</b> the given ClassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsIterable_getter the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_getter(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsIterable_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_getter(ClassInSamePackage... classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter == null) failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter does not contain the given ClassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsIterable_getter the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_getter(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_getter) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsIterable_getter(), classInSamePackageAsIterable_getter.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsIterable_getter.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsIterable_getter() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsIterable_getter but had :\n  <%s>";

    // check
    if (actual.getClassInSamePackageAsIterable_getter().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInSamePackageAsIterable_getter());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains the given ClassInSamePackage elements in Collection.
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsIterable_getter_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_getter_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_getter_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_getter_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning(), classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsIterable_getter_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_getter_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsIterable_getter_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getClassInSamePackageAsIterable_getter_subclassSamePackageAsOwning());
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsArray the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsArray(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray == null) failWithMessage("Expecting classInDifferentPackageAsArray parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInDifferentPackageAsArray).contains(classInDifferentPackageAsArray);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   *
   * @param classInDifferentPackageAsArray the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsArray(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray == null) failWithMessage("Expecting classInDifferentPackageAsArray parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInDifferentPackageAsArray).containsOnly(classInDifferentPackageAsArray);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsArray the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsArray(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray == null) failWithMessage("Expecting classInDifferentPackageAsArray parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInDifferentPackageAsArray).doesNotContain(classInDifferentPackageAsArray);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsArray.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsArray() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsArray but had :\n  <%s>";

    // check that it is not empty
    if (actual.classInDifferentPackageAsArray.length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.classInDifferentPackageAsArray));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsArray_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsArray_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInDifferentPackageAsArray_subclassSamePackageAsOwning).contains(classInDifferentPackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   *
   * @param classInDifferentPackageAsArray_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsArray_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInDifferentPackageAsArray_subclassSamePackageAsOwning).containsOnly(classInDifferentPackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsArray_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsArray_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInDifferentPackageAsArray_subclassSamePackageAsOwning).doesNotContain(classInDifferentPackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsArray_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsArray_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsArray_subclassSamePackageAsOwning but had :\n  <%s>";

    // check that it is not empty
    if (actual.classInDifferentPackageAsArray_subclassSamePackageAsOwning.length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.classInDifferentPackageAsArray_subclassSamePackageAsOwning));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField is equal to the given one.
   * @param classInDifferentPackageAsField the given classInDifferentPackageAsField to compare the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField is not equal to the given one.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsField(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage classInDifferentPackageAsField) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInDifferentPackageAsField of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage actualClassInDifferentPackageAsField = actual.classInDifferentPackageAsField;
    if (!Objects.deepEquals(actualClassInDifferentPackageAsField, classInDifferentPackageAsField)) {
      failWithMessage(assertjErrorMessage, actual, classInDifferentPackageAsField, actualClassInDifferentPackageAsField);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_subclassSamePackageAsOwning is equal to the given one.
   * @param classInDifferentPackageAsField_subclassSamePackageAsOwning the given classInDifferentPackageAsField_subclassSamePackageAsOwning to compare the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_subclassSamePackageAsOwning to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsField_subclassSamePackageAsOwning is not equal to the given one.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsField_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage classInDifferentPackageAsField_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInDifferentPackageAsField_subclassSamePackageAsOwning of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage actualClassInDifferentPackageAsField_subclassSamePackageAsOwning = actual.classInDifferentPackageAsField_subclassSamePackageAsOwning;
    if (!Objects.deepEquals(actualClassInDifferentPackageAsField_subclassSamePackageAsOwning, classInDifferentPackageAsField_subclassSamePackageAsOwning)) {
      failWithMessage(assertjErrorMessage, actual, classInDifferentPackageAsField_subclassSamePackageAsOwning, actualClassInDifferentPackageAsField_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsGenericList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList == null) failWithMessage("Expecting classInDifferentPackageAsGenericList parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsGenericList, classInDifferentPackageAsGenericList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsGenericList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsGenericList, classInDifferentPackageAsGenericList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList == null) failWithMessage("Expecting classInDifferentPackageAsGenericList parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsGenericList, classInDifferentPackageAsGenericList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsGenericList, classInDifferentPackageAsGenericList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsGenericList the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList == null) failWithMessage("Expecting classInDifferentPackageAsGenericList parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsGenericList, classInDifferentPackageAsGenericList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsGenericList the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsGenericList, classInDifferentPackageAsGenericList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsGenericList() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsGenericList but had :\n  <%s>";

    // check
    if (actual.classInDifferentPackageAsGenericList.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInDifferentPackageAsGenericList);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsGenericList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning, classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsGenericList_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsGenericList_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsGenericList_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInDifferentPackageAsGenericList_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList == null) failWithMessage("Expecting classInDifferentPackageAsList parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsList, classInDifferentPackageAsList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList == null) {
      failWithMessage("Expecting classInDifferentPackageAsList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsList, classInDifferentPackageAsList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList == null) failWithMessage("Expecting classInDifferentPackageAsList parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsList, classInDifferentPackageAsList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList == null) {
      failWithMessage("Expecting classInDifferentPackageAsList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsList, classInDifferentPackageAsList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsList the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList == null) failWithMessage("Expecting classInDifferentPackageAsList parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsList, classInDifferentPackageAsList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsList the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList == null) {
      failWithMessage("Expecting classInDifferentPackageAsList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsList, classInDifferentPackageAsList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsList() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsList but had :\n  <%s>";

    // check
    if (actual.classInDifferentPackageAsList.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInDifferentPackageAsList);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   * @param classInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsList_subclassSamePackageAsOwning, classInDifferentPackageAsList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning contains the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   * @param classInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInDifferentPackageAsList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInDifferentPackageAsList_subclassSamePackageAsOwning, classInDifferentPackageAsList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements and nothing else in whatever order.
   * @param classInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsList_subclassSamePackageAsOwning, classInDifferentPackageAsList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning contains <b>only</b> the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection and nothing else in whatever order.
   * @param classInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning does not contain all given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInDifferentPackageAsList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInDifferentPackageAsList_subclassSamePackageAsOwning, classInDifferentPackageAsList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   *
   * @param classInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage... classInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage varargs is not null.
    if (classInDifferentPackageAsList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsList_subclassSamePackageAsOwning, classInDifferentPackageAsList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning does not contain the given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements in Collection.
   *
   * @param classInDifferentPackageAsList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning contains any given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInDifferentPackageAsList_subclassSamePackageAsOwning(java.util.Collection<? extends org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage> classInDifferentPackageAsList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given org.assertj.assertions.generator.data.classRefTestdata.different_package.ClassInDifferentPackage collection is not null.
    if (classInDifferentPackageAsList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInDifferentPackageAsList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInDifferentPackageAsList_subclassSamePackageAsOwning, classInDifferentPackageAsList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInDifferentPackageAsList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInDifferentPackageAsList_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInDifferentPackageAsList_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInDifferentPackageAsList_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.classInDifferentPackageAsList_subclassSamePackageAsOwning.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInDifferentPackageAsList_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsArray the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsArray(ClassInSamePackage... classInSamePackageAsArray) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray == null) failWithMessage("Expecting classInSamePackageAsArray parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInSamePackageAsArray).contains(classInSamePackageAsArray);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   *
   * @param classInSamePackageAsArray the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray does not contain all given ClassInSamePackage elements and nothing else.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsArray(ClassInSamePackage... classInSamePackageAsArray) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray == null) failWithMessage("Expecting classInSamePackageAsArray parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInSamePackageAsArray).containsOnly(classInSamePackageAsArray);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsArray the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsArray(ClassInSamePackage... classInSamePackageAsArray) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray == null) failWithMessage("Expecting classInSamePackageAsArray parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInSamePackageAsArray).doesNotContain(classInSamePackageAsArray);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsArray.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsArray() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsArray but had :\n  <%s>";

    // check that it is not empty
    if (actual.classInSamePackageAsArray.length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.classInSamePackageAsArray));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsArray_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsArray_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInSamePackageAsArray_subclassSamePackageAsOwning).contains(classInSamePackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   *
   * @param classInSamePackageAsArray_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements and nothing else.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsArray_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInSamePackageAsArray_subclassSamePackageAsOwning).containsOnly(classInSamePackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsArray_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsArray_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsArray_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsArray_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsArray_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.classInSamePackageAsArray_subclassSamePackageAsOwning).doesNotContain(classInSamePackageAsArray_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsArray_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsArray_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsArray_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsArray_subclassSamePackageAsOwning but had :\n  <%s>";

    // check that it is not empty
    if (actual.classInSamePackageAsArray_subclassSamePackageAsOwning.length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.classInSamePackageAsArray_subclassSamePackageAsOwning));
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField is equal to the given one.
   * @param classInSamePackageAsField the given classInSamePackageAsField to compare the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField is not equal to the given one.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsField(org.assertj.assertions.generator.data.classRefTestdata.ClassInSamePackage classInSamePackageAsField) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInSamePackageAsField of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.classRefTestdata.ClassInSamePackage actualClassInSamePackageAsField = actual.classInSamePackageAsField;
    if (!Objects.deepEquals(actualClassInSamePackageAsField, classInSamePackageAsField)) {
      failWithMessage(assertjErrorMessage, actual, classInSamePackageAsField, actualClassInSamePackageAsField);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_subclassSamePackageAsOwning is equal to the given one.
   * @param classInSamePackageAsField_subclassSamePackageAsOwning the given classInSamePackageAsField_subclassSamePackageAsOwning to compare the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_subclassSamePackageAsOwning to.
   * @return this assertion object.
   * @throws AssertionError - if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsField_subclassSamePackageAsOwning is not equal to the given one.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsField_subclassSamePackageAsOwning(org.assertj.assertions.generator.data.classRefTestdata.ClassInSamePackage classInSamePackageAsField_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting classInSamePackageAsField_subclassSamePackageAsOwning of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    org.assertj.assertions.generator.data.classRefTestdata.ClassInSamePackage actualClassInSamePackageAsField_subclassSamePackageAsOwning = actual.classInSamePackageAsField_subclassSamePackageAsOwning;
    if (!Objects.deepEquals(actualClassInSamePackageAsField_subclassSamePackageAsOwning, classInSamePackageAsField_subclassSamePackageAsOwning)) {
      failWithMessage(assertjErrorMessage, actual, classInSamePackageAsField_subclassSamePackageAsOwning, actualClassInSamePackageAsField_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsGenericList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList(ClassInSamePackage... classInSamePackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList == null) failWithMessage("Expecting classInSamePackageAsGenericList parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsGenericList, classInSamePackageAsGenericList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList contains the given ClassInSamePackage elements in Collection.
   * @param classInSamePackageAsGenericList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsGenericList, classInSamePackageAsGenericList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsGenericList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList(ClassInSamePackage... classInSamePackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList == null) failWithMessage("Expecting classInSamePackageAsGenericList parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsGenericList, classInSamePackageAsGenericList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList contains <b>only</b> the given ClassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsGenericList the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsGenericList, classInSamePackageAsGenericList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsGenericList the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList(ClassInSamePackage... classInSamePackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList == null) failWithMessage("Expecting classInSamePackageAsGenericList parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsGenericList, classInSamePackageAsGenericList);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList does not contain the given ClassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsGenericList the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsGenericList, classInSamePackageAsGenericList.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsGenericList.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsGenericList() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsGenericList but had :\n  <%s>";

    // check
    if (actual.classInSamePackageAsGenericList.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInSamePackageAsGenericList);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains the given ClassInSamePackage elements in Collection.
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsGenericList_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsGenericList_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsGenericList_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsGenericList_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsGenericList_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning, classInSamePackageAsGenericList_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsGenericList_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsGenericList_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsGenericList_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsGenericList_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInSamePackageAsGenericList_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsIterable the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable(ClassInSamePackage... classInSamePackageAsIterable) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable == null) failWithMessage("Expecting classInSamePackageAsIterable parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsIterable, classInSamePackageAsIterable);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable contains the given ClassInSamePackage elements in Collection.
   * @param classInSamePackageAsIterable the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable == null) {
      failWithMessage("Expecting classInSamePackageAsIterable parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsIterable, classInSamePackageAsIterable.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsIterable the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable(ClassInSamePackage... classInSamePackageAsIterable) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable == null) failWithMessage("Expecting classInSamePackageAsIterable parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsIterable, classInSamePackageAsIterable);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable contains <b>only</b> the given ClassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsIterable the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable == null) {
      failWithMessage("Expecting classInSamePackageAsIterable parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsIterable, classInSamePackageAsIterable.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsIterable the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable(ClassInSamePackage... classInSamePackageAsIterable) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable == null) failWithMessage("Expecting classInSamePackageAsIterable parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsIterable, classInSamePackageAsIterable);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable does not contain the given ClassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsIterable the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable == null) {
      failWithMessage("Expecting classInSamePackageAsIterable parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsIterable, classInSamePackageAsIterable.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsIterable.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsIterable() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsIterable but had :\n  <%s>";

    // check
    if (actual.classInSamePackageAsIterable.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInSamePackageAsIterable);
    }

    // return the current assertion for method chaining
    return this;
  }


  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning contains the given ClassInSamePackage elements.
   * @param classInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsIterable_subclassSamePackageAsOwning, classInSamePackageAsIterable_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning contains the given ClassInSamePackage elements in Collection.
   * @param classInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasClassInSamePackageAsIterable_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.classInSamePackageAsIterable_subclassSamePackageAsOwning, classInSamePackageAsIterable_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements and nothing else in whatever order.
   * @param classInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsIterable_subclassSamePackageAsOwning, classInSamePackageAsIterable_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning contains <b>only</b> the given ClassInSamePackage elements in Collection and nothing else in whatever order.
   * @param classInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should be contained in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning does not contain all given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasOnlyClassInSamePackageAsIterable_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.classInSamePackageAsIterable_subclassSamePackageAsOwning, classInSamePackageAsIterable_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements.
   *
   * @param classInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_subclassSamePackageAsOwning(ClassInSamePackage... classInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage varargs is not null.
    if (classInSamePackageAsIterable_subclassSamePackageAsOwning == null) failWithMessage("Expecting classInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsIterable_subclassSamePackageAsOwning, classInSamePackageAsIterable_subclassSamePackageAsOwning);

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning does not contain the given ClassInSamePackage elements in Collection.
   *
   * @param classInSamePackageAsIterable_subclassSamePackageAsOwning the given elements that should not be in actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning contains any given ClassInSamePackage elements.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert doesNotHaveClassInSamePackageAsIterable_subclassSamePackageAsOwning(java.util.Collection<? extends ClassInSamePackage> classInSamePackageAsIterable_subclassSamePackageAsOwning) {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // check that given ClassInSamePackage collection is not null.
    if (classInSamePackageAsIterable_subclassSamePackageAsOwning == null) {
      failWithMessage("Expecting classInSamePackageAsIterable_subclassSamePackageAsOwning parameter not to be null.");
      return this; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.classInSamePackageAsIterable_subclassSamePackageAsOwning, classInSamePackageAsIterable_subclassSamePackageAsOwning.toArray());

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual InheritingOwningClassFromSamePackage has no classInSamePackageAsIterable_subclassSamePackageAsOwning.
   * @return this assertion object.
   * @throws AssertionError if the actual InheritingOwningClassFromSamePackage's classInSamePackageAsIterable_subclassSamePackageAsOwning is not empty.
   */
  public RefTestdataInheritingOwningClassFromSamePackageAssert hasNoClassInSamePackageAsIterable_subclassSamePackageAsOwning() {
    // check that actual InheritingOwningClassFromSamePackage we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have classInSamePackageAsIterable_subclassSamePackageAsOwning but had :\n  <%s>";

    // check
    if (actual.classInSamePackageAsIterable_subclassSamePackageAsOwning.iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.classInSamePackageAsIterable_subclassSamePackageAsOwning);
    }

    // return the current assertion for method chaining
    return this;
  }


}
